<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Love Nebula — Pro Canvas + Video Export</title>
  <style>
    :root{color-scheme:dark}
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{display:block}
    .ui{
      position:fixed;left:16px;top:16px;display:flex;gap:10px;align-items:center;
      background:rgba(0,0,0,.35);backdrop-filter:blur(8px);
      border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px 12px;
      box-shadow:0 10px 30px rgba(0,0,0,.5)
    }
    .ui button, .ui select{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#fff;border-radius:12px;padding:8px 10px;cursor:pointer;
    }
    .ui button:hover{background:rgba(255,255,255,.10)}
    .ui .pill{opacity:.85;font-size:12px}
    .ui .dot{width:10px;height:10px;border-radius:50%;background:#666;display:inline-block;margin-right:6px}
    .ui .dot.rec{background:#ff3b3b;box-shadow:0 0 20px rgba(255,60,60,.8)}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="ui">
    <span class="pill"><span id="dot" class="dot"></span><span id="status">Idle</span></span>
    <button id="start">Start Recording</button>
    <button id="stop" disabled>Stop & Download</button>
    <select id="quality" title="Recording quality">
      <option value="1">720p (fast)</option>
      <option value="1.5" selected>1080p (recommended)</option>
      <option value="2">1440p (heavy)</option>
    </select>
  </div>

<script>
(() => {
  "use strict";

  /* ==========================================================
     Engine (offscreen HDR-ish buffer + bloom buffers)
  ========================================================== */
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const hdr = document.createElement("canvas");     // scene buffer
  const hctx = hdr.getContext("2d");

  const bloomA = document.createElement("canvas");  // quarter-res
  const bloomB = document.createElement("canvas");
  const bctxA = bloomA.getContext("2d");
  const bctxB = bloomB.getContext("2d");

  const UI = {
    start: document.getElementById("start"),
    stop: document.getElementById("stop"),
    status: document.getElementById("status"),
    dot: document.getElementById("dot"),
    quality: document.getElementById("quality"),
  };

  const STATE = {
    t: 0,
    w: 0, h: 0, cx: 0, cy: 0,
    dpr: 1,
    scale: 1.5, // default for recording
    pointerX: 0, pointerY: 0,
    yaw: 0, pitch: 0, yawT: 0, pitchT: 0,
    recorder: null,
    chunks: [],
    recording: false,
  };

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const TAU   = Math.PI * 2;

  function setCanvasSize(mult=1){
    const dpr = Math.min(2, devicePixelRatio || 1);
    STATE.dpr = dpr;

    // “mult” buat render lebih besar saat record biar tajem
    const W = Math.floor(innerWidth * dpr * mult);
    const H = Math.floor(innerHeight * dpr * mult);

    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";

    hdr.width = W; hdr.height = H;

    bloomA.width  = bloomB.width  = Math.max(2, (W/4)|0);
    bloomA.height = bloomB.height = Math.max(2, (H/4)|0);

    STATE.w = W; STATE.h = H;
    STATE.cx = W * 0.5; STATE.cy = H * 0.5;
  }

  setCanvasSize(parseFloat(UI.quality.value));
  addEventListener("resize", () => setCanvasSize(parseFloat(UI.quality.value)));

  addEventListener("pointermove", (e) => {
    const nx = (e.clientX / innerWidth  - 0.5);
    const ny = (e.clientY / innerHeight - 0.5);
    STATE.pointerX = nx; STATE.pointerY = ny;
    STATE.yawT = nx * 0.55;
    STATE.pitchT = ny * 0.35;
  }, { passive:true });

  /* ==========================================================
     3D camera projection (parallax)
  ========================================================== */
  const CAM = {
    dist: 7.8,
    fov: 560,      // higher = less perspective, lower = stronger
  };

  function project3D(x,y,z){
    const yaw = STATE.yaw, pitch = STATE.pitch;

    const cy = Math.cos(yaw),  sy = Math.sin(yaw);
    const cx = Math.cos(pitch),sx = Math.sin(pitch);

    // yaw (Y)
    const x1 = x*cy + z*sy;
    const z1 = -x*sy + z*cy;

    // pitch (X)
    const y2 = y*cx - z1*sx;
    const z2 = y*sx + z1*cx;

    const zz = z2 + CAM.dist;              // camera forward
    const p  = CAM.fov / Math.max(0.001, zz);

    return { x: STATE.cx + x1*p, y: STATE.cy + y2*p, s: p, z: zz };
  }

  /* ==========================================================
     Heart curve + particle pool (veteran style)
  ========================================================== */
  function heart2D(a){
    return {
      x: 16 * Math.sin(a)**3,
      y: -(13*Math.cos(a)-5*Math.cos(2*a)-2*Math.cos(3*a)-Math.cos(4*a))
    };
  }

  class Particle {
    constructor(){ this.reset(true); }
    reset(first=false){
      this.a = Math.random()*TAU;
      this.r = Math.random();                 // radius factor
      this.z = (Math.random()*2-1);           // depth [-1..1]
      this.life = first ? 1 : (520 + Math.random()*680);
      this.size = 0.8 + Math.random()*2.2;
      this.spin = 0.010 + Math.random()*0.022;
      this.tw = Math.random()*TAU;            // twinkle phase
    }
  }

  class Pool {
    constructor(max){
      this.pool = Array.from({length:max}, ()=>new Particle());
      this.active = [];
    }
    spawn(n){
      while(n-- > 0 && this.pool.length){
        const p = this.pool.pop();
        p.reset(false);
        this.active.push(p);
      }
    }
    update(fn){
      for(let i=this.active.length-1;i>=0;i--){
        const p = this.active[i];
        fn(p);
        if(--p.life <= 0){
          this.pool.push(p);
          this.active.splice(i,1);
        }
      }
    }
  }

  const heartPool = new Pool(2400);

  // nebula / dust field
  const dust = Array.from({length:1200}, () => ({
    a: Math.random()*TAU,
    r: 80 + Math.random()*560,
    z: (Math.random()*2-1) * 5.4,
    s: 0.0007 + Math.random()*0.0025,
    sz: 0.6 + Math.random()*1.8,
  }));

  /* ==========================================================
     Rendering pipeline:
     1) Scene → HDR buffer (with trails)
     2) Bloom (downsample + blur)
     3) Composite to main canvas + grade
     4) UI text pass (NOT bloomed)
  ========================================================== */
  function clearHDR(){
    // trail persistence (cinematic)
    hctx.fillStyle = "rgba(0,0,0,0.16)";
    hctx.fillRect(0,0,STATE.w,STATE.h);

    // subtle purple fog
    hctx.save();
    hctx.globalAlpha = 0.35;
    hctx.fillStyle = "rgba(90,20,140,0.05)";
    hctx.fillRect(0,0,STATE.w,STATE.h);
    hctx.restore();
  }

  function drawGodRays(t, color){
    // cheap radial streaks (on HDR)
    hctx.save();
    hctx.translate(STATE.cx, STATE.cy);
    hctx.globalAlpha = 0.08;
    hctx.strokeStyle = color;
    hctx.lineWidth = 1.2 * STATE.dpr;

    const rays = 42;
    const base = (t*0.22) % TAU;
    for(let i=0;i<rays;i++){
      const a = base + (i/rays)*TAU;
      const len = (260 + 200*Math.sin(t*0.7+i)) * STATE.dpr;
      hctx.beginPath();
      hctx.moveTo(Math.cos(a)*20, Math.sin(a)*20);
      hctx.lineTo(Math.cos(a)*len, Math.sin(a)*len);
      hctx.stroke();
    }
    hctx.restore();
  }

  function drawDust(t){
    for(const d of dust){
      d.a += d.s;
      const x = Math.cos(d.a) * d.r;
      const y = Math.sin(d.a) * d.r * 0.75;

      const P = project3D(x,y,d.z + Math.sin(t*0.6 + d.a)*0.4);
      const r = d.sz * P.s;

      hctx.beginPath();
      hctx.arc(P.x, P.y, r, 0, TAU);
      hctx.fillStyle = "rgba(180,80,255,0.10)";
      hctx.fill();
    }
  }

  function drawHeartCore(t, color){
    // spawn steadily
    if(heartPool.active.length < 1700) heartPool.spawn(7);

    const pulse = 24 + Math.sin(t)*8;

    heartPool.update(p => {
      p.a += p.spin;
      p.z += Math.sin(t)*0.0008;

      const h = heart2D(p.a);

      // 3D heart: XY from curve, Z from particle + slight wave
      const x = h.x * pulse * p.r;
      const y = h.y * pulse * p.r;
      const z = (p.z*7.0) + Math.sin(t*0.9 + p.tw)*0.35;

      const P = project3D(x, y, z);
      const twinkle = 0.75 + 0.25*Math.sin(t*2.4 + p.tw);

      const r = p.size * P.s * twinkle;

      hctx.beginPath();
      hctx.arc(P.x, P.y, r, 0, TAU);

      // boost highlight a bit so love shape “kunci”
      hctx.fillStyle = color;
      hctx.shadowColor = color;
      hctx.shadowBlur = 26 * P.s;
      hctx.fill();

      // tiny spark rim occasionally
      if((p.life & 31) === 0){
        hctx.save();
        hctx.globalAlpha = 0.35;
        hctx.beginPath();
        hctx.arc(P.x, P.y, r*2.4, 0, TAU);
        hctx.strokeStyle = "rgba(255,255,255,0.25)";
        hctx.lineWidth = 1.0 * STATE.dpr;
        hctx.stroke();
        hctx.restore();
      }
    });
  }

  function bloomPass(){
    const bw = bloomA.width, bh = bloomA.height;

    // downsample with "brighten"
    bctxA.save();
    bctxA.clearRect(0,0,bw,bh);
    bctxA.filter = "brightness(1.45) contrast(1.10) saturate(1.15)";
    bctxA.drawImage(hdr, 0,0,STATE.w,STATE.h, 0,0,bw,bh);
    bctxA.restore();

    // blur ping-pong
    bctxB.save();
    bctxB.clearRect(0,0,bw,bh);
    bctxB.filter = "blur(10px)";
    bctxB.globalAlpha = 0.95;
    bctxB.drawImage(bloomA,0,0);
    bctxB.restore();

    bctxA.save();
    bctxA.clearRect(0,0,bw,bh);
    bctxA.filter = "blur(18px)";
    bctxA.globalAlpha = 0.85;
    bctxA.drawImage(bloomB,0,0);
    bctxA.restore();

    // final soften
    bctxA.save();
    bctxA.filter = "blur(6px)";
    bctxA.globalAlpha = 0.65;
    bctxA.drawImage(bloomB,0,0);
    bctxA.restore();
  }

  function vignette(){
    const g = ctx.createRadialGradient(STATE.cx,STATE.cy, Math.min(STATE.w,STATE.h)*0.12,
                                       STATE.cx,STATE.cy, Math.max(STATE.w,STATE.h)*0.62);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.58)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,STATE.w,STATE.h);
  }

  function compositeFinal(t){
    ctx.save();
    ctx.clearRect(0,0,STATE.w,STATE.h);

    // “HDR-ish grading”
    ctx.filter = "brightness(1.06) contrast(1.20) saturate(1.25) hue-rotate(-6deg)";
    ctx.drawImage(hdr,0,0);
    ctx.restore();

    // bloom add
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.globalAlpha = 0.88;
    ctx.filter = "brightness(1.10) contrast(1.05)";
    ctx.drawImage(bloomA, 0,0,bloomA.width,bloomA.height, 0,0,STATE.w,STATE.h);
    ctx.restore();

    // vignette (post)
    vignette();
  }

  function drawUIText(t, color){
    // UI text NOT in HDR => always readable
    const a = clamp((t-0.7)*0.25, 0, 1);
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 0.95 * a;

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // glow
    ctx.shadowColor = color;
    ctx.shadowBlur  = 22 * STATE.dpr;

    // main line
    ctx.font = `800 ${Math.floor(72*STATE.dpr)}px system-ui, -apple-system, Segoe UI, Roboto`;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fillText("I Love You", STATE.cx, STATE.cy + 240*STATE.dpr);

    // small subtitle (optional)
    ctx.shadowBlur = 14 * STATE.dpr;
    ctx.font = `500 ${Math.floor(18*STATE.dpr)}px system-ui, -apple-system, Segoe UI, Roboto`;
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fillText("— made with love —", STATE.cx, STATE.cy + 290*STATE.dpr);

    ctx.restore();
  }

  function colorAt(t){
    // romantic red-magenta range (lebih “love” daripada ungu doang)
    const r = (210 + 45*Math.sin(t*0.9))|0;
    const g = ( 45 + 35*Math.sin(t*0.9 + 2.0))|0;
    const b = (110 + 55*Math.sin(t*0.9 + 4.0))|0;
    return `rgb(${r},${g},${b})`;
  }

  /* ==========================================================
     Main loop
  ========================================================== */
  function tick(){
    // smooth parallax camera
    STATE.yaw   = lerp(STATE.yaw,   STATE.yawT,   0.06);
    STATE.pitch = lerp(STATE.pitch, STATE.pitchT, 0.06);

    const t = STATE.t;
    const col = colorAt(t);

    clearHDR();
    drawGodRays(t, col);
    drawDust(t);
    drawHeartCore(t, col);

    bloomPass();
    compositeFinal(t);
    drawUIText(t, col);

    STATE.t += 0.035;
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  /* ==========================================================
     Video Export (WEBM) — record canvas
  ========================================================== */
  function pickMime(){
    const candidates = [
      "video/webm;codecs=vp9",
      "video/webm;codecs=vp8",
      "video/webm"
    ];
    return candidates.find(m => MediaRecorder.isTypeSupported(m)) || "";
  }

  function startRecording(){
    // render at chosen scale
    const mult = parseFloat(UI.quality.value);
    setCanvasSize(mult);

    const stream = canvas.captureStream(60); // 60fps target
    const mime = pickMime();

    const rec = new MediaRecorder(stream, {
      mimeType: mime,
      videoBitsPerSecond: 12_000_000  // kualitas bagus (turun/naik sesuai device)
    });

    STATE.chunks = [];
    rec.ondataavailable = (e) => { if(e.data && e.data.size) STATE.chunks.push(e.data); };
    rec.onstop = () => {
      const blob = new Blob(STATE.chunks, { type: rec.mimeType || "video/webm" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `love_heart_${Date.now()}.webm`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      setTimeout(()=>URL.revokeObjectURL(url), 5000);

      STATE.recording = false;
      UI.stop.disabled = true;
      UI.start.disabled = false;
      UI.status.textContent = "Saved";
      UI.dot.classList.remove("rec");

      // balik ke normal preview scale (biar ringan)
      setCanvasSize(parseFloat(UI.quality.value));
    };

    rec.start(200); // chunk per 200ms
    STATE.recorder = rec;
    STATE.recording = true;

    UI.stop.disabled = false;
    UI.start.disabled = true;
    UI.status.textContent = "Recording…";
    UI.dot.classList.add("rec");
  }

  function stopRecording(){
    if(STATE.recorder && STATE.recording){
      UI.status.textContent = "Finalizing…";
      STATE.recorder.stop();
    }
  }

  UI.start.addEventListener("click", startRecording);
  UI.stop.addEventListener("click", stopRecording);

})();
</script>
</body>
</html>
